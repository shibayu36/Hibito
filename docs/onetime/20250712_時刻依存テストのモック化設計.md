# 時刻依存テストのモック化設計

**作成日**: 2025/07/12  
**更新日**: 2025/07/14  
**目的**: TodoListViewModelの時刻依存テストを安定化するためのDateProviderパターン導入

## 背景

現在、TodoListViewModelのリセット機能テストにおいて、時刻に依存する処理のテストが困難な状況です。

### 現状分析（詳細調査結果）

#### 時刻依存処理の具体的な問題箇所
1. **TodoListViewModel.swift:138行目** - `performReset()`メソッド
   ```swift
   let lastResetTime = getLastResetTime(now: Date())  // ← Date()直接使用
   ```
   - 現在時刻を`Date()`で直接取得しているため、テスト時に時刻制御ができない
   - この箇所がテスタビリティを阻害する主要因

2. **getLastResetTime()メソッド** - 110〜128行目
   - パラメータで時刻を受け取る設計のため、既にテスタブル
   - 修正は不要だが、呼び出し元の改善が必要

#### 既存テストケースへの影響分析
**TodoListViewModelTests.swift**の調査結果：

**影響を受けるテストケース（2つ）**：
1. `昨日作成されたTodoはすべて削除される()` - `performReset()`内のDate()使用で影響
2. `今日作成されたTodoはすべて残る()` - TodoItem作成時とperformReset()両方で影響

**影響を受けないテストケース（2つ）**：
1. `getLastResetTime`関連の2つのテスト - 手動で時刻を指定しているため変更不要

### 現在の課題
- `performReset()`が`Date()`を直接使用（138行目）
- テスト実行タイミングによって結果が変わる可能性
- 特定の時刻でのリセット動作を検証しにくい
- TodoItem作成時の`createdAt`も`Date()`に依存

### 改善したいテストケース
- リセット時刻9時設定で、現在8時の場合の削除判定
- リセット時刻9時設定で、現在10時の場合の削除判定
- 時刻制御されたTodoItem作成とリセット動作の組み合わせテスト

## 設計案：DateProviderプロトコルパターン

### 1. DateProviderプロトコルの完全な定義

**ファイル配置**: `Hibito/DateProvider.swift`（新規作成済み）

```swift
import Foundation

/// 時刻取得を抽象化するプロトコル
/// テスト時の時刻制御と本番時の実時刻取得を統一的に扱う
protocol DateProvider {
    /// 現在時刻を取得
    var now: Date { get }
}

/// 本番・実機用のDateProvider
/// 実際のシステム時刻を返す
struct SystemDateProvider: DateProvider {
    var now: Date { Date() }
}

/// テスト用のDateProvider
/// 固定された時刻を返すため、テスト時の時刻制御が可能
struct MockDateProvider: DateProvider {
    private(set) var fixedDate: Date
    var now: Date { fixedDate }
    
    init(fixedDate: Date = Date()) {
        self.fixedDate = fixedDate
    }
    
    /// ISO8601形式の文字列から時刻を設定
    /// - Parameter iso8601String: ISO8601形式の日時文字列 (例: "2025-01-14T15:30:00+09:00")
    mutating func setDate(_ iso8601String: String) {
        let formatter = ISO8601DateFormatter()
        formatter.formatOptions = [.withInternetDateTime, .withTimeZone]
        
        if let date = formatter.date(from: iso8601String) {
            self.fixedDate = date
        }
    }
}
```

### 2. TodoListViewModel修正（具体的な変更箇所）

**修正箇所1**: initializerにDateProvider追加
```swift
// 18〜22行目を以下に変更
init(modelContext: ModelContext, 
     settingsRepository: SettingsRepository,
     dateProvider: DateProvider = SystemDateProvider()) {
    self.modelContext = modelContext
    self.settingsRepository = settingsRepository
    self.dateProvider = dateProvider  // 追加
    loadTodos()
}
```

**修正箇所2**: プロパティ追加
```swift
// 15行目付近に追加
private let dateProvider: DateProvider
```

**修正箇所3**: performReset()の138行目を修正
```swift
// 変更前
let lastResetTime = getLastResetTime(now: Date())

// 変更後  
let lastResetTime = getLastResetTime(now: dateProvider.now)
```

**修正箇所4**: addTodo()メソッドでTodoItem作成時の時刻制御
```swift
// addTodo()メソッド内のTodoItem作成箇所
let newTodo = TodoItem(content: content, order: maxOrder + 1.0)
newTodo.createdAt = dateProvider.now  // 追加：時刻制御
```

### 3. 更新が必要な既存テストケース

**TodoListViewModelTests.swift**で修正が必要な2つのテストケース：

#### 修正例1: `昨日作成されたTodoはすべて削除される()`

```swift
@Test
func 昨日作成されたTodoはすべて削除される() async throws {
    // MockDateProviderで現在時刻を制御
    let mockDateProvider = MockDateProvider(hour: 10)  // 今日の10時に固定
    
    let container = try createTestContainer()
    let context = container.mainContext
    let settingsRepository = SettingsRepository(modelContext: context)
    let viewModel = TodoListViewModel(
        modelContext: context, 
        settingsRepository: settingsRepository,
        dateProvider: mockDateProvider  // 追加
    )
    
    // 昨日作成のTodoを手動で作成（createdAtを直接設定）
    let yesterdayTodo = TodoItem(content: "昨日のタスク", order: 1.0)
    let yesterday = Calendar.current.date(byAdding: .day, value: -1, to: mockDateProvider.now)!
    yesterdayTodo.createdAt = yesterday
    context.insert(yesterdayTodo)
    
    viewModel.loadTodos()
    #expect(viewModel.todos.count == 1)
    
    viewModel.performReset()
    
    #expect(viewModel.todos.count == 0)
}
```

#### 修正例2: `今日作成されたTodoはすべて残る()`

```swift
@Test
func 今日作成されたTodoはすべて残る() async throws {
    let mockDateProvider = MockDateProvider(hour: 10)
    
    let container = try createTestContainer()
    let context = container.mainContext
    let settingsRepository = SettingsRepository(modelContext: context)
    let viewModel = TodoListViewModel(
        modelContext: context, 
        settingsRepository: settingsRepository,
        dateProvider: mockDateProvider
    )
    
    // addTodo()を使用してTodoを作成（内部でdateProvider.nowが使用される）
    viewModel.addTodo("今日のタスク")
    
    #expect(viewModel.todos.count == 1)
    
    viewModel.performReset()
    
    #expect(viewModel.todos.count == 1)
}
```

### 4. 新しいテストケース実装例

#### リセット時刻による削除/残存の境界テスト

```swift
@Test
func リセット時刻9時_現在8時_昨日作成のTodoは削除と残存が混在() async throws {
    // 現在時刻を今日の8時に固定
    let mockDateProvider = MockDateProvider(hour: 8)
    
    let container = try createTestContainer()
    let context = container.mainContext
    let settingsRepository = SettingsRepository(modelContext: context)
    settingsRepository.updateResetTime(9)  // リセット時刻を9時に設定
    
    let viewModel = TodoListViewModel(
        modelContext: context, 
        settingsRepository: settingsRepository,
        dateProvider: mockDateProvider
    )
    
    // 昨日の8時作成Todo（削除対象：リセット時刻9時より前）
    let yesterdayEarly = TodoItem(content: "昨日8時のタスク", order: 1.0)
    let yesterdayEarlyTime = Calendar.current.date(byAdding: .day, value: -1, to:
        Calendar.current.date(bySettingHour: 8, minute: 0, second: 0, of: mockDateProvider.now)!)!
    yesterdayEarly.createdAt = yesterdayEarlyTime
    context.insert(yesterdayEarly)
    
    // 昨日の10時作成Todo（残存対象：リセット時刻9時より後）
    let yesterdayLate = TodoItem(content: "昨日10時のタスク", order: 2.0)
    let yesterdayLateTime = Calendar.current.date(byAdding: .day, value: -1, to:
        Calendar.current.date(bySettingHour: 10, minute: 0, second: 0, of: mockDateProvider.now)!)!
    yesterdayLate.createdAt = yesterdayLateTime
    context.insert(yesterdayLate)
    
    viewModel.loadTodos()
    #expect(viewModel.todos.count == 2)
    
    // リセット実行
    viewModel.performReset()
    
    // 昨日8時のTodoは削除、昨日10時のTodoは残存
    #expect(viewModel.todos.count == 1)
    #expect(viewModel.todos[0].content == "昨日10時のタスク")
}

@Test
func リセット時刻9時_現在10時_今日作成のTodoはすべて残存() async throws {
    // 現在時刻を今日の10時に固定（リセット時刻9時を過ぎている）
    let mockDateProvider = MockDateProvider(hour: 10)
    
    let container = try createTestContainer()
    let context = container.mainContext
    let settingsRepository = SettingsRepository(modelContext: context)
    settingsRepository.updateResetTime(9)
    
    let viewModel = TodoListViewModel(
        modelContext: context, 
        settingsRepository: settingsRepository,
        dateProvider: mockDateProvider
    )
    
    // addTodo()で今日のTodoを作成（内部でmockDateProvider.nowが使用される）
    viewModel.addTodo("今日10時のタスク")
    
    #expect(viewModel.todos.count == 1)
    
    viewModel.performReset()
    
    // 今日のリセット時刻（9時）より後に作成されたので残存
    #expect(viewModel.todos.count == 1)
}
```

## 段階的実装計画

### ✅ Phase 1: DateProviderプロトコルの導入（完了）
**作業内容**:
1. ✅ `Hibito/DateProvider.swift`ファイルを新規作成
2. ✅ `DateProvider`プロトコル、`SystemDateProvider`、`MockDateProvider`を実装
3. ✅ `DateProviderTests.swift`でテストケース作成・実行確認

**検証結果**:
- ✅ プロジェクトがビルドできることを確認
- ✅ テストが全件通過（3件のテストケース）
- ✅ MockDateProviderの動作確認完了
  - デフォルト初期化での固定値確認
  - 特定日時での初期化確認  
  - ISO8601文字列での時刻変更確認

**完了日**: 2025/07/14

### Phase 2: TodoListViewModelの修正
**作業内容**:
1. `private let dateProvider: DateProvider`プロパティを追加
2. initializerを修正してDateProviderを注入可能にする
3. `performReset()`の138行目を`dateProvider.now`使用に変更
4. `addTodo()`でTodoItem作成時に`dateProvider.now`を使用

**検証方法**:
- 既存テストがすべて通ることを確認
- iOSシミュレータでアプリが正常に動作することを確認

### Phase 3: 既存テストケースの更新
**作業内容**:
1. `昨日作成されたTodoはすべて削除される()`テストを更新
2. `今日作成されたTodoはすべて残る()`テストを更新
3. MockDateProviderを使用した時刻制御に変更

**検証方法**:
- 更新したテストケースが正常に通ること
- `getLastResetTime`関連のテストは変更不要で通ること

### Phase 4: 新しい境界テストケースの追加
**作業内容**:
1. リセット時刻による削除/残存境界テストを追加
2. 時刻制御されたより詳細なテストケースの実装

**検証方法**:
- 新しいテストケースがすべて通ること
- カバレッジが向上していること

### Phase 5: 統合テストと動作確認
**作業内容**:
1. 全テストスイートの実行確認
2. iOSシミュレータでの実機動作確認
3. リセット機能の手動テスト

**検証方法**:
```bash
# テスト実行
mcp__XcodeBuildMCP__test_sim_name_proj({
  projectPath: "Hibito.xcodeproj",
  scheme: "Hibito", 
  simulatorName: "iPhone 16"
})

# iOSシミュレータビルド確認
xcodebuild -scheme Hibito -sdk iphonesimulator -destination 'platform=iOS Simulator,name=iPhone 16' build
```

## メリット

1. **テストの安定性**: 固定時刻でテストできるため実行タイミングに依存しない
2. **責務分離**: 時刻取得の責務を独立したプロトコルに分離
3. **既存APIの維持**: イニシャライザのデフォルト引数で後方互換性を保持
4. **拡張性**: 将来的にタイムゾーン対応などの他のプロバイダも追加可能
5. **境界テストの実現**: リセット時刻前後での動作を正確にテスト可能
6. **TodoItem作成時刻の制御**: addTodo()経由でのTodo作成時も時刻制御が可能

## 実装時の注意点

### SwiftData・@MainActor関連
- DateProviderプロトコル自体には`@MainActor`は不要
- TodoListViewModelには既に`@MainActor`が適用済みのため追加対応不要
- MockDateProviderは構造体のため、@MainActorでのアクセス制約なし

### テスト実行時の確認事項
1. **既存テストの回帰確認**: 変更前と同じテスト結果になること
2. **新しいテストの動作確認**: MockDateProviderが期待通りに動作すること
3. **実機動作の確認**: デフォルト引数により既存の動作が保持されること

### ファイル配置の考慮事項
- ✅ `DateProvider.swift`は`Hibito/`直下に配置（完了）
- ✅ `DateProviderTests.swift`をテストディレクトリに配置（完了）
- ✅ プロジェクトファイル(.xcodeproj)への適切な追加が必要（完了）
- ✅ テストターゲットからもアクセス可能にする設定（完了）

## 影響範囲まとめ

### 修正が必要なファイル
1. ✅ **新規作成**: `Hibito/DateProvider.swift`（完了）
2. ✅ **新規作成**: `HibitoTests/DateProviderTests.swift`（完了）
3. **修正**: `ViewModels/TodoListViewModel.swift` (4箇所)
4. **修正**: `HibitoTests/ViewModels/TodoListViewModelTests.swift` (2つのテストケース)

### 影響を受けないファイル
- `Models/TodoItem.swift` - データモデルは変更不要
- `Views/` - UIレイヤーは影響なし
- `Repositories/SettingsRepository.swift` - 設定関連は影響なし
- 既存の`getLastResetTime`テスト - 手動時刻指定のため変更不要

## 将来の拡張可能性

この設計により以下の機能拡張が容易になります：

1. **タイムゾーン対応**: `TimezoneAwareDateProvider`の追加
2. **テスト用シナリオ**: 特定の日時進行をシミュレーションする`ProgressiveDateProvider`
3. **デバッグ機能**: 開発時に時刻を手動制御する`DebugDateProvider`
4. **モニタリング**: 時刻取得をログ出力する`LoggingDateProvider`

この実装により、時刻依存のロジックをより安全で拡張性の高い設計に改善できます✨