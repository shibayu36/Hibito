# リセット時間設定機能 要件定義

## 概要
現在0時固定となっているTODOリストの自動リセット時間を、ユーザーが1時間単位で設定できるようにする機能。

## 背景
- 現在のHibitoアプリは毎日0時に全タスクが自動的に削除される
- ユーザーによっては0時以外の時間（例：朝6時、夜9時など）にリセットしたい需要がある
- ユーザーのライフスタイルに合わせた柔軟な設定を可能にする

## 機能要件

### 1. 設定画面
- **アクセス方法**
  - TodoListViewのヘッダー部分に歯車アイコンを配置
  - タップするとNavigationLinkで設定画面へ遷移
  
- **設定項目**
  - リセット時間の選択
    - 24時間表記（0:00〜23:00）
    - 1時間刻みでの選択
    - デフォルト値：0:00（午前0時）
  
- **UI仕様**
  - Pickerを使用した時間選択
  - 選択後は自動的に保存される
  - 今後の拡張性を考慮したレイアウト（iCloud連携などの設定追加を想定）

### 2. リセット時間の動作
- 設定された時間になったら、その時間より前に作成されたタスクを削除
- 例：リセット時間が朝6:00の場合
  - 6:00になったら、6:00より前に作成されたタスクが削除対象
  - 5:59に作成したタスクは6:00に削除される
  - 6:01に作成したタスクは翌日の6:00まで残る

### 3. データ保存
- UserDefaultsを使用して設定値を永続化
- アプリ再起動後も設定が維持される

## 技術設計

### アーキテクチャ
MVVMパターン + Repository パターンを採用
```
SettingsView → SettingsViewModel → SettingsRepository → UserDefaults
```

### ディレクトリ構造
```
Hibito/
├── Repositories/
│   └── SettingsRepository.swift    # データアクセス層
├── ViewModels/
│   ├── TodoListViewModel.swift     # 既存
│   └── SettingsViewModel.swift     # 新規作成
├── Views/
│   ├── TodoListView.swift          # UI修正
│   └── SettingsView.swift          # 新規作成
├── Extensions/
│   └── Date+Extensions.swift       # 機能拡張
└── Models/
    └── TodoItem.swift              # 変更なし
```

### 実装コンポーネント

#### 1. SettingsRepository.swift
```swift
import Foundation

@Observable
class SettingsRepository {
    private let userDefaults = UserDefaults.standard
    private let resetTimeKey = "resetTime"
    
    var resetTime: Int {
        didSet {
            userDefaults.set(resetTime, forKey: resetTimeKey)
        }
    }
    
    init() {
        resetTime = userDefaults.object(forKey: resetTimeKey) as? Int ?? 0
    }
    
    // 今日の指定時刻のDateを取得
    func getResetDate() -> Date {
        let calendar = Calendar.current
        let now = Date()
        return calendar.date(bySettingHour: resetTime, minute: 0, second: 0, of: now) ?? now
    }
}
```

#### 2. SettingsViewModel.swift
```swift
import Foundation

@Observable
class SettingsViewModel {
    private let settingsRepository: SettingsRepository
    
    var resetTime: Int {
        get { settingsRepository.resetTime }
        set { settingsRepository.resetTime = newValue }
    }
    
    init(settingsRepository: SettingsRepository = SettingsRepository()) {
        self.settingsRepository = settingsRepository
    }
    
    // 表示用の時間文字列を生成
    func formattedResetTime() -> String {
        return String(format: "%02d:00", resetTime)
    }
    
    // 設定の説明文を生成
    func resetTimeDescription() -> String {
        return "毎日\(formattedResetTime())に、それより前に作成されたタスクが自動的に削除されます"
    }
}
```

#### 3. SettingsView.swift
```swift
import SwiftUI

struct SettingsView: View {
    @State private var viewModel = SettingsViewModel()
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        NavigationStack {
            Form {
                Section {
                    Picker("リセット時間", selection: $viewModel.resetTime) {
                        ForEach(0..<24, id: \.self) { hour in
                            Text(String(format: "%02d:00", hour)).tag(hour)
                        }
                    }
                    .pickerStyle(.wheel)
                } header: {
                    Text("リセット時間")
                } footer: {
                    Text(viewModel.resetTimeDescription())
                }
            }
            .navigationTitle("設定")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("完了") {
                        dismiss()
                    }
                }
            }
        }
    }
}
```

#### 4. Date+Extensions.swift への追加
```swift
extension Date {
    // 既存の isBeforeToday() はそのまま
    
    // 指定時刻より前に作成されたかを判定
    func isBeforeResetTime(_ resetTime: Int) -> Bool {
        let calendar = Calendar.current
        let now = Date()
        
        // 今日の指定時刻
        guard let todayResetTime = calendar.date(bySettingHour: resetTime, minute: 0, second: 0, of: now) else {
            return false
        }
        
        // 作成日時が今日の指定時刻より前で、かつ今の時刻が指定時刻を過ぎている場合
        if now >= todayResetTime {
            return self < todayResetTime
        }
        
        // まだ今日の指定時刻になっていない場合は、昨日の指定時刻と比較
        guard let yesterdayResetTime = calendar.date(byAdding: .day, value: -1, to: todayResetTime) else {
            return false
        }
        
        return self < yesterdayResetTime
    }
}
```

#### 5. TodoListView.swift への修正
```swift
// ツールバーに追加
.toolbar {
    ToolbarItem(placement: .navigationBarTrailing) {
        Button {
            showingSettings = true
        } label: {
            Image(systemName: "gear")
        }
    }
}
.sheet(isPresented: $showingSettings) {
    SettingsView()
}

// プロパティに追加
@State private var showingSettings = false
```

#### 6. TodoListViewModel.swift への修正
```swift
@Observable
class TodoListViewModel {
    private let settingsRepository = SettingsRepository()
    
    // 既存のコード...
    
    // performReset()を修正
    func performReset() {
        let allItems = loadAllTodos()
        let resetTime = settingsRepository.resetTime
        
        let tasksToDelete = allItems.filter { item in
            item.createdAt.isBeforeResetTime(resetTime)
        }
        
        for task in tasksToDelete {
            modelContext.delete(task)
        }
        
        if !tasksToDelete.isEmpty {
            try? modelContext.save()
        }
    }
}
```

### 実装順序

1. **SettingsRepository.swift**の実装
2. **Date+Extensions**の拡張
3. **SettingsViewModel.swift**の実装
4. **SettingsView.swift**の実装
5. **TodoListView.swift**の修正（設定画面への遷移）
6. **TodoListViewModel.swift**の修正（Repository連携）
7. **テストの実装**
8. **動作確認**

### テスト設計

#### SettingsRepositoryTests.swift
- デフォルト値の確認
- UserDefaultsへの保存確認
- getResetDate()の動作確認

#### SettingsViewModelTests.swift
- resetTimeのバインディング確認
- formattedResetTime()の動作確認
- resetTimeDescription()の動作確認
- MockRepositoryを使った分離テスト

#### Date+ExtensionsTests.swift への追加
- isBeforeResetTime()の各種時間パターンのテスト
- 日付変更をまたぐケースのテスト
- タイムゾーンの考慮

### 設計の利点

1. **テスタビリティ向上**：
   - ViewModelを単体でテストできる
   - MockRepositoryを使った分離テスト
   - UIロジックをテストしやすい

2. **責務分離**：
   - View：UI表示のみ
   - ViewModel：UIロジック、データ変換
   - Repository：データアクセス

3. **拡張性**：
   - 設定画面の複雑なロジックをViewModel内に集約
   - バリデーションやビジネスロジックの追加が容易

4. **保守性**：
   - ViewとRepositoryの結合度が低い
   - 依存性注入でテストしやすい

### 破綻する可能性

1. **タイムゾーン対応**が必要になった場合
2. **より細かい時間設定**が必要になった場合（30分単位など）
3. **複数のリセット条件**が必要になった場合
4. **iCloud同期**が必要になった場合

これらの問題に対しても、Repository パターンにより対応しやすい構造になっている。
